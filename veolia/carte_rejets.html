<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carte des Rejets - Avec Filtres</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="carte-common.css" />
    <style>
        :root {
            --carte-theme: #01665E;
            --carte-theme-bg: #e8f4f8;
        }
    </style>
</head>
<body>
    <div id="filters">
        <h2>üîç Filtres - Rejets</h2>
        
        <div id="stats">
            Sites affich√©s : <span id="countVisible">0</span> / <span id="countTotal">0</span>
        </div>
        <div class="filter-section">
            <h3>üîé Recherche</h3>
            <input type="text" id="searchName" placeholder="Nom d'√©tablissement... (+ pour combiner)" title="Un mot : recherche sur ce mot. Plusieurs groupes s√©par√©s par + : affiche les sites qui contiennent au moins un des groupes (ex. BEL + EDF).">
        </div>
        
        <div class="filter-section">
            <h3>üìç Zoom sur...</h3>
            <input type="text" id="searchCity" placeholder="Ville ou code postal...">
            <button type="button" id="zoomCity" class="btn-zoom">Zoomer</button>
            <div id="zoomMessage" class="zoom-message" hidden>Aucun √©tablissement trouv√©</div>
        </div>
        
        <div class="filter-section">
            <h3>üìä Volume total (m¬≥/an)</h3>
            <label><input type="checkbox" class="volume-filter" value="small" checked> &lt; 10 000</label>
            <label><input type="checkbox" class="volume-filter" value="medium" checked> 10 000 - 100 000</label>
            <label><input type="checkbox" class="volume-filter" value="large" checked> 100 000 - 1 000 000</label>
            <label><input type="checkbox" class="volume-filter" value="xlarge" checked> &gt; 1 000 000</label>
        </div>
        
        <div class="filter-section">
            <h3>üè≠ Type de rejet</h3>
            <label><input type="checkbox" class="type-filter" value="raccorde" checked> Rejets raccord√©s uniquement</label>
            <label><input type="checkbox" class="type-filter" value="isole" checked> Rejets isol√©s uniquement</label>
            <label><input type="checkbox" class="type-filter" value="both" checked> Les deux types</label>
        </div>
        
        <div class="filter-section">
            <h3>üó∫Ô∏è R√©gion</h3>
            <select id="regionFilter">
                <option value="">Toutes les r√©gions</option>
            </select>
        </div>
        
        <div class="filter-section">
            <h3>üè¢ Code APE</h3>
            <div class="section-ape-buttons">
                <button type="button" id="sectionAll" class="btn-section-all">Tout</button>
                <button type="button" id="sectionNone" class="btn-section-none">Aucun</button>
            </div>
            <input type="text" id="searchApe" class="search-ape" placeholder="Filtrer les codes APE..." title="Recherche dans le code et le libell√©">
            <div class="checkbox-group" id="sectionList">
                <!-- Liste des codes APE g√©n√©r√©e depuis les donn√©es -->
            </div>
        </div>

        <div class="filter-section">
            <button type="button" id="exportCsv" class="btn-export" title="T√©l√©charge la liste des √©tablissements actuellement affich√©s sur la carte">üì• Exporter au format .csv</button>
        </div>

        <div class="legend">
            <h3>L√©gende</h3>
            <p><span class="legend-color" style="background:#48C9B0;"></span> Rejets raccord√©s</p>
            <p><span class="legend-color" style="background:#FF9866;"></span> Rejets isol√©s</p>
        </div>
    </div>
    
    <div id="map"></div>
    
    <a href="index.html" class="btn-back">‚Üê Retour</a>
    
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="carte-common.js"></script>
    <script src="data/js/rejets_v2.js"></script>
    <script>
        // Carte Rejets ‚Äî Structure : CONFIG ‚Üí CARTE ‚Üí IC√îNES ‚Üí DONN√âES & UI ‚Üí FILTRES ‚Üí √âV√âNEMENTS
        // Code APE et utilitaires : carte-common.js
        // Liste Section APE : synchronis√©e avec data/sites_par_code_ape.csv et outils/generate_ape_counts.py

        // ==================== CONFIG ====================
        const MAP_CENTER = [48.8566, 2.3522];
        const MAP_ZOOM_INITIAL = 10;
        const MAP_ZOOM_VILLE = 13;
        const TILE_URL = 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';
        const TILE_ATTRIBUTION = '&copy; Esri, Maxar, Earthstar Geographics, and the GIS User Community';

        const rejetColors = {
            'Raccordes': 'rgba(72, 201, 176, 0.85)',
            'Isoles': 'rgba(255, 152, 102, 0.85)',
        };

        // Aliases vers carte-common.js (code APE + utilitaires)
        const getSectionFromCode = CarteCommon.getSectionFromCode;
        const getDivisionFromCode = CarteCommon.getDivisionFromCode;
        const getGroup10FromCode = CarteCommon.getGroup10FromCode;
        const cleanNumber = CarteCommon.cleanNumber;
        const escapeRegExp = CarteCommon.escapeRegExp;

        // ==================== CARTE ====================
        const map = L.map('map').setView(MAP_CENTER, MAP_ZOOM_INITIAL);
        L.tileLayer(TILE_URL, { maxZoom: 19, attribution: TILE_ATTRIBUTION }).addTo(map);

        // ==================== IC√îNES (camemberts) ====================
        // √âtat des marqueurs : liste compl√®te + marqueurs visibles apr√®s filtres
        let allMarkers = [];
        let visibleMarkers = [];
        function createPieChartSVG(raccorde, isole, size) {
            const radius = size / 2;
            const center = size / 2;
            const total = raccorde + isole;
            
            if (total === 0) {
                return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                    <circle cx="${center}" cy="${center}" r="${radius}" fill="#ccc"/>
                </svg>`;
            }

            let svg = `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">`;
            let startAngle = -90;
            
            const segments = [
                { value: raccorde, color: rejetColors['Raccordes'] },
                { value: isole, color: rejetColors['Isoles'] }
            ];

            segments.forEach(segment => {
                if (segment.value > 0) {
                    const angle = (segment.value / total) * 360;
                    const endAngle = startAngle + angle;
                    const largeArc = angle > 180 ? 1 : 0;
                    
                    const x1 = center + radius * Math.cos(startAngle * Math.PI / 180);
                    const y1 = center + radius * Math.sin(startAngle * Math.PI / 180);
                    const x2 = center + radius * Math.cos(endAngle * Math.PI / 180);
                    const y2 = center + radius * Math.sin(endAngle * Math.PI / 180);
                    
                    if (angle >= 360) {
                        svg += `<circle cx="${center}" cy="${center}" r="${radius}" fill="${segment.color}"/>`;
                    } else {
                        svg += `<path d="M ${center} ${center} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2} Z" fill="${segment.color}"/>`;
                    }
                    startAngle = endAngle;
                }
            });
            
            svg += `</svg>`;
            return svg;
        }

        // Fonction pour cr√©er une ic√¥ne
        function createCustomIcon(raccorde, isole, total) {
            const minSize = 10;
            const maxSize = 60;
            let size = minSize;
            
            if (total > 0) {
                const minValueGlobal = 15;
                const maxValueGlobal = 5e9;
                const logMin = Math.log10(minValueGlobal);
                const logMax = Math.log10(maxValueGlobal);
                const t = (Math.log10(total) - logMin) / (logMax - logMin);
                size = Math.max(minSize, Math.min(maxSize, minSize + t * (maxSize - minSize)));
            }
            
            const pieChartSVG = createPieChartSVG(raccorde, isole, size);
            
            return L.divIcon({
                className: 'custom-icon',
                html: pieChartSVG,
                iconSize: [size, size],
                iconAnchor: [size/2, size/2]
            });
        }

        // ==================== DONN√âES & UI ====================
        const regions = new Set();
        
        etablissements.etablissements.forEach(etab => {
            if (etab.region) regions.add(etab.region);
        });

        // Remplir le select des r√©gions
        const regionSelect = document.getElementById('regionFilter');
        [...regions].sort().forEach(region => {
            const option = document.createElement('option');
            option.value = region;
            option.textContent = region;
            regionSelect.appendChild(option);
        });

        // Liste des codes APE tels que dans les donn√©es (un par code_ape distinct)
        function buildApeCheckboxes() {
            const codeToLibelle = new Map();
            etablissements.etablissements.forEach(etab => {
                if (etab.code_ape && !codeToLibelle.has(etab.code_ape)) {
                    codeToLibelle.set(etab.code_ape, etab.libelle_ape || etab.code_ape);
                }
            });
            const codes = [...codeToLibelle.keys()].sort();
            const container = document.getElementById('sectionList');
            container.innerHTML = '';
            codes.forEach(code => {
                const libelle = codeToLibelle.get(code);
                const label = document.createElement('label');
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.className = 'section-filter';
                cb.value = code;
                cb.checked = true;
                label.appendChild(cb);
                label.appendChild(document.createTextNode(' ' + code + ' - ' + libelle));
                container.appendChild(label);
            });
        }
        buildApeCheckboxes();

        function initMarkers() {
            document.getElementById('countTotal').textContent = etablissements.etablissements.length;
            
            etablissements.etablissements.forEach(etab => {
                const raccordeVal = cleanNumber(etab.rejet_raccorde_m3_par_an);
                const isoleVal = cleanNumber(etab.rejet_isole_m3_par_an);
                const totalVal = cleanNumber(etab.somme_rejets);
                
                if (totalVal === 0) return;
                
                const marker = L.marker(
                    [etab.latitude, etab.longitude],
                    { icon: createCustomIcon(raccordeVal, isoleVal, totalVal) }
                );
                
                const formatValue = (val) => val === 0 ? "0" : val.toLocaleString('fr-FR');
                
                const textContent = `√âtablissement : ${etab.nom_etablissement}
Adresse : ${etab.adresse || ''}, ${etab.code_postal || ''} ${etab.commune || ''}
R√©gion : ${etab.region || 'N/A'}
Code APE : ${etab.code_ape || 'N/A'}
Libell√© APE : ${etab.libelle_ape || 'N/A'}
Rejet raccord√© : ${formatValue(raccordeVal)} m¬≥
Rejet isol√© : ${formatValue(isoleVal)} m¬≥
Total rejets : ${formatValue(totalVal)} m¬≥`;

                const popupContent = `
                    <div class="info-window info-window__header">
                    <button type="button" class="btn-copy" onclick="navigator.clipboard.writeText(\`${textContent.replace(/`/g, '\\`')}\`).then(() => { this.innerHTML = '‚úì'; setTimeout(() => this.innerHTML = '<svg width=\\'16\\' height=\\'16\\' viewBox=\\'0 0 24 24\\' fill=\\'none\\' stroke=\\'currentColor\\' stroke-width=\\'2\\'><rect x=\\'9\\' y=\\'9\\' width=\\'13\\' height=\\'13\\' rx=\\'2\\' ry=\\'2\\'></rect><path d=\\'M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\\'></path></svg>', 1500); })" title="Copier"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button>
                    <p><strong>√âtablissement :</strong> ${etab.nom_etablissement}</p>
                    <p><strong>Adresse :</strong> ${etab.adresse || ''}, ${etab.code_postal || ''} ${etab.commune || ''}</p>
                    <p><strong>R√©gion :</strong> ${etab.region || 'N/A'}</p>
                    <p><strong>Code APE :</strong> ${etab.code_ape || 'N/A'}</p>
                    <p><strong>Libell√© APE :</strong> ${etab.libelle_ape || 'N/A'}</p>
                    <p><strong>Rejet raccord√© :</strong> ${formatValue(raccordeVal)} m¬≥</p>
                    <p><strong>Rejet isol√© :</strong> ${formatValue(isoleVal)} m¬≥</p>
                    <p><strong>Total rejets :</strong> ${formatValue(totalVal)} m¬≥</p>
                    </div>
                `;
                marker.bindPopup(popupContent);
                
                allMarkers.push({
                    marker: marker,
                    data: etab,
                    raccordeVal: raccordeVal,
                    isoleVal: isoleVal,
                    totalVal: totalVal
                });
            });
            
            applyFilters();
        }

        // ==================== FILTRES ====================
        function applyFilters() {
            // Retirer les marqueurs actuels
            visibleMarkers.forEach(m => map.removeLayer(m.marker));
            visibleMarkers = [];
            
            // R√©cup√©rer les filtres
            const searchName = document.getElementById('searchName').value.trim();
            const selectedRegion = document.getElementById('regionFilter').value;
            
            const volumeFilters = [...document.querySelectorAll('.volume-filter:checked')].map(cb => cb.value);
            const typeFilters = [...document.querySelectorAll('.type-filter:checked')].map(cb => cb.value);
            const sectionFilters = [...document.querySelectorAll('.section-filter:checked')].map(cb => cb.value);
            
            allMarkers.forEach(m => {
                const etab = m.data;
                let visible = true;
                
                // Filtre par nom : "mot" = mot entier ; "A + B" = sites contenant A OU B (mots entiers)
                if (searchName) {
                    const nom = etab.nom_etablissement || '';
                    const parts = searchName.split('+').map(s => s.trim()).filter(Boolean);
                    const nameMatch = parts.length === 0 ? true : parts.some(part => {
                        const safe = escapeRegExp(part);
                        return new RegExp(`\\b${safe}\\b`, 'i').test(nom);
                    });
                    if (!nameMatch) visible = false;
                }
                
                // Filtre par r√©gion
                if (selectedRegion && etab.region !== selectedRegion) {
                    visible = false;
                }
                
                // Filtre par volume
                if (volumeFilters.length > 0) {
                    let volumeMatch = false;
                    if (volumeFilters.includes('small') && m.totalVal < 10000) volumeMatch = true;
                    if (volumeFilters.includes('medium') && m.totalVal >= 10000 && m.totalVal < 100000) volumeMatch = true;
                    if (volumeFilters.includes('large') && m.totalVal >= 100000 && m.totalVal < 1000000) volumeMatch = true;
                    if (volumeFilters.includes('xlarge') && m.totalVal >= 1000000) volumeMatch = true;
                    if (!volumeMatch) visible = false;
                }
                
                // Filtre par type
                if (typeFilters.length > 0 && typeFilters.length < 3) {
                    let typeMatch = false;
                    const hasRaccorde = m.raccordeVal > 0;
                    const hasIsole = m.isoleVal > 0;
                    
                    if (typeFilters.includes('raccorde') && hasRaccorde && !hasIsole) typeMatch = true;
                    if (typeFilters.includes('isole') && hasIsole && !hasRaccorde) typeMatch = true;
                    if (typeFilters.includes('both') && hasRaccorde && hasIsole) typeMatch = true;
                    if (!typeMatch) visible = false;
                }
                
                // Filtre par code APE : aucune coch√©e = rien afficher ; codes tels que dans les donn√©es
                if (sectionFilters.length === 0) {
                    visible = false;
                } else if (!etab.code_ape || !sectionFilters.includes(etab.code_ape)) {
                    visible = false;
                }
                
                if (visible) {
                    m.marker.addTo(map);
                    visibleMarkers.push(m);
                }
            });
            
            document.getElementById('countVisible').textContent = visibleMarkers.length;
            document.getElementById('exportCsv').disabled = visibleMarkers.length === 0;
        }

        function zoomToCity() {
            const searchTerm = document.getElementById('searchCity').value.trim().toLowerCase();
            if (!searchTerm) return;
            
            // Chercher les √©tablissements par commune OU code postal
            const matchingEtabs = etablissements.etablissements.filter(etab => {
                const matchCommune = etab.commune && etab.commune.toLowerCase().includes(searchTerm);
                const matchCodePostal = etab.code_postal && etab.code_postal.toString().startsWith(searchTerm);
                return matchCommune || matchCodePostal;
            });
            
            const zoomMsg = document.getElementById('zoomMessage');
            if (matchingEtabs.length > 0) {
                zoomMsg.hidden = true;
                let sumLat = 0, sumLon = 0;
                matchingEtabs.forEach(etab => {
                    sumLat += parseFloat(etab.latitude);
                    sumLon += parseFloat(etab.longitude);
                });
                const centerLat = sumLat / matchingEtabs.length;
                const centerLon = sumLon / matchingEtabs.length;
                map.setView([centerLat, centerLon], MAP_ZOOM_VILLE);
            } else {
                zoomMsg.hidden = false;
            }
        }

        // ==================== √âV√âNEMENTS ====================
        document.getElementById('searchName').addEventListener('input', applyFilters);
        document.getElementById('regionFilter').addEventListener('change', applyFilters);
        
        // Zoom sur ville
        document.getElementById('zoomCity').addEventListener('click', zoomToCity);
        document.getElementById('searchCity').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') zoomToCity();
        });
        document.getElementById('searchCity').addEventListener('input', () => {
            document.getElementById('zoomMessage').hidden = true;
        });
        document.querySelectorAll('.volume-filter, .type-filter, .section-filter').forEach(cb => {
            cb.addEventListener('change', applyFilters);
        });

        document.getElementById('sectionAll').addEventListener('click', () => {
            document.querySelectorAll('.section-filter').forEach(cb => cb.checked = true);
            applyFilters();
        });
        document.getElementById('sectionNone').addEventListener('click', () => {
            document.querySelectorAll('.section-filter').forEach(cb => cb.checked = false);
            applyFilters();
        });

        // Recherche dans la liste des codes APE (affiche/masque les lignes)
        document.getElementById('searchApe').addEventListener('input', function () {
            const q = this.value.trim().toLowerCase();
            document.querySelectorAll('#sectionList label').forEach(label => {
                const text = (label.textContent || '').toLowerCase();
                label.style.display = (!q || text.includes(q)) ? '' : 'none';
            });
        });

        // Export CSV : √©tablissements actuellement affich√©s (recalcul √† partir des filtres pour √™tre s√ªr)
        function csvEscape(val) {
            if (val == null) return '';
            const s = String(val).trim();
            if (/[,"\r\n]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
            return s;
        }
        function getVisibleForExport() {
            const searchName = document.getElementById('searchName').value.trim();
            const selectedRegion = document.getElementById('regionFilter').value;
            const volumeFilters = [...document.querySelectorAll('.volume-filter:checked')].map(cb => cb.value);
            const typeFilters = [...document.querySelectorAll('.type-filter:checked')].map(cb => cb.value);
            const sectionFilters = [...document.querySelectorAll('.section-filter:checked')].map(cb => cb.value);
            return allMarkers.filter(m => {
                const etab = m.data;
                if (searchName) {
                    const nom = etab.nom_etablissement || '';
                    const parts = searchName.split('+').map(s => s.trim()).filter(Boolean);
                    if (parts.length > 0 && !parts.some(part => new RegExp('\\b' + escapeRegExp(part) + '\\b', 'i').test(nom))) return false;
                }
                if (selectedRegion && etab.region !== selectedRegion) return false;
                if (volumeFilters.length > 0) {
                    let ok = false;
                    if (volumeFilters.includes('small') && m.totalVal < 10000) ok = true;
                    if (volumeFilters.includes('medium') && m.totalVal >= 10000 && m.totalVal < 100000) ok = true;
                    if (volumeFilters.includes('large') && m.totalVal >= 100000 && m.totalVal < 1000000) ok = true;
                    if (volumeFilters.includes('xlarge') && m.totalVal >= 1000000) ok = true;
                    if (!ok) return false;
                }
                if (typeFilters.length > 0 && typeFilters.length < 3) {
                    const hasRaccorde = m.raccordeVal > 0, hasIsole = m.isoleVal > 0;
                    let ok = (typeFilters.includes('raccorde') && hasRaccorde && !hasIsole) || (typeFilters.includes('isole') && hasIsole && !hasRaccorde) || (typeFilters.includes('both') && hasRaccorde && hasIsole);
                    if (!ok) return false;
                }
                if (sectionFilters.length === 0) return false;
                if (!etab.code_ape || !sectionFilters.includes(etab.code_ape)) return false;
                // Ne garder que les √©tablissements dans la zone visible de la carte (zoom + position)
                const lat = parseFloat(etab.latitude);
                const lon = parseFloat(etab.longitude);
                if (isNaN(lat) || isNaN(lon) || !map.getBounds().contains([lat, lon])) return false;
                return true;
            });
        }
        function exportCsv() {
            const toExport = getVisibleForExport();
            if (toExport.length === 0) return;
            const cols = ['identifiant', 'nom_etablissement', 'adresse', 'code_postal', 'commune', 'departement', 'region', 'code_ape', 'libelle_ape', 'latitude', 'longitude', 'rejet_raccorde_m3_par_an', 'rejet_isole_m3_par_an', 'somme_rejets'];
            const header = cols.map(c => csvEscape(c)).join(',');
            const rows = toExport.map(m => {
                const e = m.data;
                return [e.identifiant, e.nom_etablissement, e.adresse, e.code_postal, e.commune, e.departement, e.region, e.code_ape, e.libelle_ape, e.latitude, e.longitude, m.raccordeVal, m.isoleVal, m.totalVal].map(csvEscape).join(',');
            });
            const csv = '\uFEFF' + [header, ...rows].join('\r\n');
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'rejets_sites_affiches.csv';
            a.click();
            URL.revokeObjectURL(a.href);
        }
        document.getElementById('exportCsv').addEventListener('click', exportCsv);

        initMarkers();
    </script>
</body>
</html>
