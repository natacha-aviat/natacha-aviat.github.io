<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MaMaExpress - Association MaMaMa</title>
    <link rel="stylesheet" href="../../assets/css/MaMaStyle.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        .top-section {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            margin-bottom: 20px;
        }
        .top-section .input-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 600px;
            padding: 0 !important;
            margin: 0 !important;
            background-color: transparent !important;
            box-shadow: none !important;
        }
        .top-section .results-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 0 !important;
            margin: 0 !important;
        }
        .address-input,
        .routes-list {
            display: flex;
            flex-direction: column;
            padding: 20px;
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin: 0 !important;
        }
        .address-input {
            height: 100%;
        }
        .address-input h3,
        .routes-header h3 {
            margin: 0 0 15px 0 !important;
            padding: 0 !important;
            line-height: 1.2 !important;
            font-size: 1.3em;
        }
        .pmi-controls {
            flex-shrink: 0;
            margin-bottom: 15px;
        }
        .pmi-list {
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }
        .routes-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin: 0 0 15px 0;
            padding: 0;
        }
        .routes-header h3 {
            flex: 1;
        }
        #googleMapsButton {
            margin: 0;
            padding: 0;
        }
        .google-maps-btn {
            display: inline-block;
            padding: 10px 20px;
            background-color: #FFC107;
            color: #2C3E50;
            text-decoration: none;
            border-radius: 5px;
            font-weight: bold;
            vertical-align: top;
        }
        #routes {
            overflow-y: auto;
            padding-right: 10px;
        }
        #mapContainer {
            width: 100%;
            height: 600px;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #customAddress:focus {
            outline: none;
            border-color: #FFC107;
            box-shadow: 0 0 0 2px rgba(255, 193, 7, 0.2);
        }
        #calculateCustomAddress:hover {
            background-color: #FFB300 !important;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        }
        #calculateCustomAddress:active {
            transform: translateY(0);
        }
        #calculateCustomAddress:disabled {
            background-color: #cccccc !important;
            color: #666 !important;
            cursor: not-allowed;
            transform: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div style="display: flex; align-items: center; justify-content: center; gap: 15px; margin-bottom: 20px;">
            <img src="https://images.squarespace-cdn.com/content/v1/5ec8595ff51b0459bf5c59d8/d36a9706-f7a7-444a-9a13-fb2ee27373e8/mamama_logo.png?format=1500w" alt="Association MaMaMa" style="height: 80px; width: auto; max-width: 160px;">
            <h1 style="margin: 0;">MaMaExpress</h1>
        </div>
        
        <div id="topSection" class="top-section">
            <div class="input-section">
                <div class="address-input">
                    <h3>S√©lectionner les adresses √† livrer</h3>
                    <div class="pmi-controls">
                        <input type="text" id="searchPmi" placeholder="Rechercher une PMI..." class="search-input">
                        <div class="select-buttons">
                            <button id="selectAll" class="select-button">Tout s√©lectionner</button>
                            <button id="deselectAll" class="select-button">Tout d√©s√©lectionner</button>
                        </div>
                    </div>
                    <div id="pmiList" class="pmi-list">
                        <p style="color: #666;">Chargement des donn√©es...</p>
                    </div>
                    <div class="custom-address-section" style="margin-top: 25px; padding: 20px; background-color: #fff; border-radius: 5px; border-left: 4px solid #FFC107; box-shadow: 0 2px 8px rgba(0,0,0,0.1); border-top: 1px solid #e0e0e0; border-right: 1px solid #e0e0e0; border-bottom: 1px solid #e0e0e0;">
                        <h4 style="margin: 0 0 15px 0; font-size: 1.15em; color: #2C3E50; display: flex; align-items: center; gap: 8px;">
                            <span style="width: 28px; height: 28px; background-color: #FFC107; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 16px; flex-shrink: 0;">üìç</span>
                            Ajouter une adresse personnalis√©e
                        </h4>
                        <div style="display: flex; gap: 10px; align-items: flex-start;">
                            <input type="text" id="customAddress" placeholder="Entrez une adresse (ex: 10 rue de la Paix, Paris)" 
                                   style="flex: 1; padding: 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; transition: border-color 0.3s;">
                            <button id="calculateCustomAddress" class="select-button" style="white-space: nowrap; padding: 12px 24px; background-color: #FFC107; color: #2C3E50; font-weight: bold; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s;">
                                Calculer
                            </button>
                        </div>
                        <div id="customAddressStatus" style="margin-top: 12px; font-size: 0.9em; color: #666; min-height: 20px;"></div>
                        <div id="customAddressesList" style="margin-top: 18px; display: none; padding-top: 15px; border-top: 1px solid #e8e8e8;">
                            <div style="font-weight: bold; margin-bottom: 10px; font-size: 0.95em; color: #2C3E50;">Adresses personnalis√©es ajout√©es :</div>
                            <div id="customAddressesItems" style="display: flex; flex-direction: column; gap: 8px;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="results" class="results-section">
                <div id="routesListContainer" class="routes-list">
                    <div class="routes-header">
                        <h3>Itin√©raire optimis√©</h3>
                        <div id="googleMapsButton"></div>
                    </div>
                    <div id="routes"></div>
                </div>
            </div>
        </div>

        <div id="mapContainer"></div>
    </div>
    <div class="footer">
        Pour toute id√©e d'am√©lioration, contactez Natacha : <a href="mailto:digital@asso-mamama.fr">digital@asso-mamama.fr</a>
    </div>

    <script src="../../assets/js/pmi_addresses.js"></script>
    <script src="../../assets/js/pmi_durees.js"></script>

    <script>
        let allPmis = [];
        let filteredPmis = [];
        let dureesMap = new Map();
        let selectedPmiIndices = new Set();
        let currentMap = null;
        let isMapInitializing = false;
        let customAddresses = []; // Stocke les adresses personnalis√©es ajout√©es
        
        function initializeFromJS() {
            if (typeof PMI_ADDRESSES === 'undefined') {
                console.error('PMI_ADDRESSES non d√©fini. V√©rifiez que pmi_addresses.js est charg√©.');
                document.getElementById('pmiList').innerHTML = 
                    '<p style="color: red;">‚ùå Erreur : Fichier pmi_addresses.js non charg√©</p>';
                return;
            }
            
            if (typeof PMI_DUREES === 'undefined') {
                console.error('PMI_DUREES non d√©fini. V√©rifiez que pmi_durees.js est charg√©.');
                return;
            }
            
            if (typeof MAMAMA_ADDRESS === 'undefined') {
                MAMAMA_ADDRESS = "rue Louis Girard, Aubervilliers";
            }
            
            allPmis = PMI_ADDRESSES.map(pmi => ({
                nom: pmi.nom,
                address: pmi.address,
                lat: pmi.lat,
                lng: pmi.lng
            }));
            
            filteredPmis = [...allPmis];
            displayPmis();
            updateSelectedCount();
            
            dureesMap.clear();
            for (const [key, value] of Object.entries(PMI_DUREES)) {
                dureesMap.set(key, value);
            }
            
            setTimeout(() => {
                calculateRoutes();
            }, 200);
        }

        function displayPmis() {
            const pmiListDiv = document.getElementById('pmiList');
            
            document.querySelectorAll('.pmi-checkbox:checked').forEach(cb => {
                const idx = parseInt(cb.dataset.index);
                selectedPmiIndices.add(idx);
            });
            
            pmiListDiv.innerHTML = '';
            
            if (filteredPmis.length === 0) {
                pmiListDiv.innerHTML = '<p>Aucune PMI trouv√©e</p>';
                updateSelectedCount();
                return;
            }

            filteredPmis.forEach((pmi, index) => {
                const pmiIndex = allPmis.indexOf(pmi);
                const isChecked = selectedPmiIndices.has(pmiIndex);
                
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'pmi-item';
                
                const checkboxInput = document.createElement('input');
                checkboxInput.type = 'checkbox';
                checkboxInput.id = `pmi-${index}`;
                checkboxInput.dataset.index = pmiIndex;
                checkboxInput.className = 'pmi-checkbox';
                checkboxInput.checked = isChecked;
                
                const label = document.createElement('label');
                label.htmlFor = `pmi-${index}`;
                label.innerHTML = `
                    <strong>${pmi.nom}</strong><br>
                    <span class="pmi-address">${pmi.address}</span>
                `;
                
                checkboxDiv.appendChild(checkboxInput);
                checkboxDiv.appendChild(label);
                pmiListDiv.appendChild(checkboxDiv);
            });
            
            pmiListDiv.addEventListener('change', function(e) {
                if (e.target && e.target.classList.contains('pmi-checkbox')) {
                    handlePmiToggle(e.target);
                }
            });
            
            pmiListDiv.addEventListener('click', function(e) {
                if (e.target.tagName === 'LABEL' || e.target.closest('label')) {
                    const label = e.target.tagName === 'LABEL' ? e.target : e.target.closest('label');
                    const checkboxId = label.getAttribute('for');
                    if (checkboxId) {
                        const checkbox = document.getElementById(checkboxId);
                        if (checkbox && checkbox.classList.contains('pmi-checkbox')) {
                            setTimeout(() => {
                                handlePmiToggle(checkbox);
                            }, 10);
                        }
                    }
                }
            });
            
            updateSelectedCount();
        }

        function handlePmiToggle(checkbox) {
            const idx = parseInt(checkbox.dataset.index);
            const pmi = allPmis[idx];
            if (checkbox.checked) {
                selectedPmiIndices.add(idx);
            } else {
                selectedPmiIndices.delete(idx);
            }
            updateSelectedCount();
        }

        function filterPmis(searchTerm) {
            if (allPmis.length === 0) return;
            
            const term = (searchTerm || '').toLowerCase().trim();
            if (term === '') {
                filteredPmis = [...allPmis];
            } else {
                filteredPmis = allPmis.filter(pmi => {
                    const nomMatch = pmi.nom && pmi.nom.toLowerCase().includes(term);
                    const addressMatch = pmi.address && pmi.address.toLowerCase().includes(term);
                    return nomMatch || addressMatch;
                });
            }
            
            
            displayPmis();
        }

        function updateSelectedCount() {
            setTimeout(() => {
                calculateRoutes();
            }, 100);
        }

        function getAddressId(address) {
            if (!address || typeof PMI_ADDRESS_TO_ID === 'undefined') {
                return null;
            }
            let id = PMI_ADDRESS_TO_ID[address];
            if (id !== undefined) {
                return id;
            }
            if (typeof PMI_ADDRESSES !== 'undefined') {
                for (const pmi of PMI_ADDRESSES) {
                    if (pmi.address === address) {
                        return pmi.id;
                    }
                }
            }
            if (typeof MAMAMA_ADDRESS !== 'undefined' && address === MAMAMA_ADDRESS) {
                return typeof MAMAMA_ID !== 'undefined' ? MAMAMA_ID : null;
            }
            return null;
        }

        function getDuree(adresse1, adresse2) {
            const id1 = getAddressId(adresse1);
            const id2 = getAddressId(adresse2);
            
            if (id1 === null || id2 === null) {
                // Si l'une des adresses est personnalis√©e, calculer la dur√©e approximative
                const custom1 = customAddresses.find(addr => addr.address === adresse1);
                const custom2 = customAddresses.find(addr => addr.address === adresse2);
                
                if (custom1 || custom2) {
                    return calculateEstimatedDuration(adresse1, adresse2);
                }
                return Infinity;
            }
            
            const key = `${id1}|${id2}`;
            const duree = dureesMap.get(key);
            
            return duree !== undefined ? duree : Infinity;
        }

        // Calcule la distance en kilom√®tres entre deux points (formule de Haversine)
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371; // Rayon de la Terre en km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLng / 2) * Math.sin(dLng / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // Calcule une dur√©e estim√©e bas√©e sur la distance
        function calculateEstimatedDuration(adresse1, adresse2) {
            let lat1, lng1, lat2, lng2;
            
            // Trouver les coordonn√©es de la premi√®re adresse
            if (adresse1 === MAMAMA_ADDRESS) {
                lat1 = 48.90355834151138;
                lng1 = 2.378094237324154;
            } else {
                const custom1 = customAddresses.find(addr => addr.address === adresse1);
                if (custom1) {
                    lat1 = custom1.lat;
                    lng1 = custom1.lng;
                } else {
                    const pmi1 = allPmis.find(pmi => pmi.address === adresse1);
                    if (pmi1) {
                        lat1 = pmi1.lat;
                        lng1 = pmi1.lng;
                    } else {
                        return Infinity;
                    }
                }
            }
            
            // Trouver les coordonn√©es de la deuxi√®me adresse
            if (adresse2 === MAMAMA_ADDRESS) {
                lat2 = 48.90355834151138;
                lng2 = 2.378094237324154;
            } else {
                const custom2 = customAddresses.find(addr => addr.address === adresse2);
                if (custom2) {
                    lat2 = custom2.lat;
                    lng2 = custom2.lng;
                } else {
                    const pmi2 = allPmis.find(pmi => pmi.address === adresse2);
                    if (pmi2) {
                        lat2 = pmi2.lat;
                        lng2 = pmi2.lng;
                    } else {
                        return Infinity;
                    }
                }
            }
            
            const distance = calculateDistance(lat1, lng1, lat2, lng2);
            // Vitesse moyenne en ville : 30 km/h, avec un facteur de correction pour les trajets urbains
            // On ajoute aussi un temps de base pour les arr√™ts/feux rouges
            const vitesseMoyenne = 30; // km/h
            const tempsBase = 2; // minutes de base pour chaque trajet
            const dureeMinutes = (distance / vitesseMoyenne) * 60 + tempsBase;
            
            return Math.round(dureeMinutes);
        }

        async function calculateOptimalOrder(waypoints) {
            if (dureesMap.size === 0) {
                throw new Error('Les dur√©es de trajet n\'ont pas √©t√© charg√©es. Veuillez recharger la page.');
            }
            
            const n = waypoints.length;
            const dureesMatrix = [];
            
            for (let i = 0; i < n; i++) {
                dureesMatrix[i] = [];
                for (let j = 0; j < n; j++) {
                    if (i === j) {
                        dureesMatrix[i][j] = 0;
                    } else {
                        const duree = getDuree(waypoints[i].address, waypoints[j].address);
                        dureesMatrix[i][j] = duree;
                    }
                }
            }

            const visited = new Set([0]);
            const order = [0];
            
            while (visited.size < waypoints.length) {
                let minDuree = Infinity;
                let nextPoint = -1;
                const currentPoint = order[order.length - 1];
                
                for (let i = 0; i < n; i++) {
                    if (!visited.has(i)) {
                        const duree = dureesMatrix[currentPoint][i];
                        if (duree < minDuree) {
                            minDuree = duree;
                            nextPoint = i;
                        }
                    }
                }
                
                if (nextPoint === -1 || minDuree === Infinity) {
                    for (let i = 0; i < n; i++) {
                        if (!visited.has(i)) {
                            nextPoint = i;
                            break;
                        }
                    }
                    if (nextPoint === -1) break;
                }
                
                visited.add(nextPoint);
                order.push(nextPoint);
            }
                
            if (order.length <= 30) {
                let amelioration = true;
                let iterations = 0;
                const maxIterations = 10;
                
                while (amelioration && iterations < maxIterations) {
                    amelioration = false;
                    iterations++;
                    const n = order.length;
                    
                    for (let i = 0; i < n - 2; i++) {
                        for (let j = i + 2; j < n - 1; j++) {
                            const d_i_i1 = dureesMatrix[order[i]][order[i + 1]];
                            const d_j_j1 = dureesMatrix[order[j]][order[j + 1]];
                            const d_i_j = dureesMatrix[order[i]][order[j]];
                            const d_i1_j1 = dureesMatrix[order[i + 1]][order[j + 1]];
                            
                            if (d_i_i1 === Infinity || d_j_j1 === Infinity || 
                                d_i_j === Infinity || d_i1_j1 === Infinity) {
                                continue;
                            }
                            
                            const gain = d_i_i1 + d_j_j1 - d_i_j - d_i1_j1;
                            
                            if (gain > 0) {
                                let start = i + 1;
                                let end = j;
                                while (start < end) {
                                    const temp = order[start];
                                    order[start] = order[end];
                                    order[end] = temp;
                                    start++;
                                    end--;
                                }
                                amelioration = true;
                                break;
                            }
                        }
                        if (amelioration) break;
                    }
                }
            }
            
            return order;
        }

        async function calculateRoutes() {
            document.getElementById('results').style.display = 'block';

            const selectedIndices = Array.from(selectedPmiIndices);
            const selectedPmis = selectedIndices.map(index => allPmis[index]);

            await new Promise(resolve => setTimeout(resolve, 50));

            try {
                const mamamaLat = 48.90355834151138;
                const mamamaLng = 2.378094237324154;
                
                const locations = [{
                    nom: 'MaMaMa (D√©part)',
                    address: MAMAMA_ADDRESS,
                    lat: mamamaLat,
                    lng: mamamaLng
                }];
                
                for (const pmi of selectedPmis) {
                    locations.push({
                        nom: pmi.nom,
                        address: pmi.address,
                        lat: pmi.lat,
                        lng: pmi.lng
                    });
                }
                
                // Ajouter les adresses personnalis√©es
                for (const customAddr of customAddresses) {
                    locations.push({
                        nom: customAddr.nom || 'Adresse personnalis√©e',
                        address: customAddr.address,
                        lat: customAddr.lat,
                        lng: customAddr.lng
                    });
                }

                if (selectedPmis.length === 0 && customAddresses.length === 0) {
                    displayRoute(locations);
                    return;
                }

                const optimalOrder = await calculateOptimalOrder(locations);
                const orderedWaypoints = optimalOrder.map(index => locations[index]);
                
                displayRoute(orderedWaypoints);
                
            } catch (error) {
                console.error('Erreur compl√®te:', error);
                alert(`Erreur lors du calcul: ${error.message}\n\nV√©rifiez la console pour plus de d√©tails.`);
            }
        }

        function displayRoute(waypoints) {
            const routesDiv = document.getElementById('routes');
            routesDiv.innerHTML = '';
            
            const topSection = document.getElementById('topSection');
            const routesListContainer = document.getElementById('routesListContainer');
            
            if (waypoints.length === 1) {
                topSection.style.alignItems = 'flex-start';
                if (routesListContainer) {
                    routesListContainer.style.height = 'auto';
                    routesListContainer.style.minHeight = 'auto';
                }
            } else {
                topSection.style.alignItems = 'stretch';
                if (routesListContainer) {
                    routesListContainer.style.height = '100%';
                    routesListContainer.style.minHeight = '600px';
                }
            }

            const routeDiv = document.createElement('div');
            routeDiv.className = 'route';
            
            let dureeTotale = 0;
            for (let i = 0; i < waypoints.length - 1; i++) {
                const duree = getDuree(waypoints[i].address, waypoints[i + 1].address);
                if (duree !== Infinity) {
                    dureeTotale += duree;
                }
            }
            const dernierPoint = waypoints[waypoints.length - 1];
            const dureeRetour = getDuree(dernierPoint.address, waypoints[0].address);
            if (dureeRetour !== Infinity) {
                dureeTotale += dureeRetour;
            }
            
            let html = '';
            if (dureeTotale > 0) {
                const minutesArrondies = Math.round(dureeTotale);
                const heures = Math.floor(dureeTotale / 60);
                const minutesRestantes = Math.round(dureeTotale % 60);
                const formatHeures = minutesRestantes > 0 ? `${heures}h${minutesRestantes.toString().padStart(2, '0')}` : `${heures}h`;
                html += `<p><strong>Dur√©e totale estim√©e : ${minutesArrondies} minutes (${formatHeures})</strong></p>`;
                html += `<p style="margin-top: 10px; padding: 12px; background-color: #f5f5f5; border-left: 3px solid #666; color: #555; font-size: 0.9em; line-height: 1.5;">
                    <strong>Note :</strong> Les dur√©es indiqu√©es sont des estimations bas√©es sur des conditions de circulation normales. Elles ne prennent pas en compte les bouchons, les accidents, les conditions m√©t√©orologiques ou d'autres √©v√©nements pouvant affecter le trafic. Les temps de trajet r√©els peuvent varier.
                </p>`;
            }
            if (waypoints.length === 1) {
                html += `<p style="color: #666; font-style: italic;">S√©lectionnez des PMI pour voir l'itin√©raire optimis√©.</p>`;
            } else {
                html += `<ol start="0"><li><strong>${waypoints[0].address}</strong> (D√©part)</li>`;
                for (let i = 1; i < waypoints.length; i++) {
                    const displayName = waypoints[i].nom 
                        ? `${waypoints[i].nom} - ${waypoints[i].address}` 
                        : waypoints[i].address;
                    html += `<li>${displayName}</li>`;
                }
                if (waypoints.length > 1) {
                    html += `<li><strong>${waypoints[0].address}</strong> (Retour)</li>`;
                }
                html += `</ol>`;
            }
            
            routeDiv.innerHTML = html;
            routesDiv.appendChild(routeDiv);
            
            const googleMapsButtonDiv = document.getElementById('googleMapsButton');
            googleMapsButtonDiv.innerHTML = '';
            if (waypoints.length > 1) {
                const { url: googleMapsUrl, limited } = buildGoogleMapsUrl(waypoints);
                const mapsLink = document.createElement('a');
                mapsLink.href = googleMapsUrl;
                mapsLink.target = '_blank';
                mapsLink.className = 'google-maps-btn';
                if (limited) {
                    mapsLink.textContent = 'Voir l\'itin√©raire (9 premi√®res adresses)';
                } else {
                    mapsLink.textContent = 'Voir l\'itin√©raire sur Google Maps';
                }
                mapsLink.addEventListener('click', function() {
                    // Ouverture de Google Maps
                });
                googleMapsButtonDiv.appendChild(mapsLink);
            }
            
            displayMap(waypoints);
            document.getElementById('results').style.display = 'block';
        }

        function displayMap(waypoints) {
            if (isMapInitializing) return;
            isMapInitializing = true;
            try {
                const mapContainer = document.getElementById('mapContainer');
                if (!mapContainer) {
                    console.warn('mapContainer non trouv√©, la carte ne sera pas affich√©e');
                    isMapInitializing = false;
                    return;
                }
                
                if (currentMap) {
                    try {
                        currentMap.remove();
                    } catch (e) {}
                    currentMap = null;
                }
                
                if (mapContainer._leaflet_id) {
                    delete mapContainer._leaflet_id;
                }
                mapContainer.innerHTML = '';
                
                if (waypoints.length === 0) {
                    mapContainer.innerHTML = '<p style="padding: 20px; text-align: center; color: #666;">S√©lectionnez des PMI pour voir la carte</p>';
                    isMapInitializing = false;
                    return;
                }
            
            let hasCoordinates = false;
            for (const wp of waypoints) {
                if (wp.lat && wp.lng) {
                    hasCoordinates = true;
                    break;
                }
            }
            
            if (!hasCoordinates) {
                mapContainer.innerHTML = '<p style="padding: 20px; text-align: center; color: #666;">Coordonn√©es non disponibles pour l\'affichage de la carte</p>';
                isMapInitializing = false;
                return;
            }
            
            setTimeout(() => {
                const container = document.getElementById('mapContainer');
                if (!container || container.offsetParent === null) {
                    console.warn('mapContainer non visible, report de l\'initialisation de la carte');
                    return;
                }
                
                if (container._leaflet_id) {
                    delete container._leaflet_id;
                    container.innerHTML = '';
                }
                
                let initialCenter = [48.8566, 2.3522];
                let initialZoom = 11;
                if (waypoints.length > 0 && waypoints[0].lat && waypoints[0].lng) {
                    initialCenter = [waypoints[0].lat, waypoints[0].lng];
                    initialZoom = 13;
                }
                
                const map = L.map('mapContainer', {
                    center: initialCenter,
                    zoom: initialZoom
                });
                currentMap = map;
                
                L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
                    attribution: '¬© CARTO ¬© OpenStreetMap contributors',
                    subdomains: 'abcd',
                    maxZoom: 19
                }).addTo(map);
                
                map.whenReady(() => {
                    const markers = [];
                    const latlngs = [];
                    
                    if (waypoints[0].lat && waypoints[0].lng) {
                        const startMarker = L.marker([waypoints[0].lat, waypoints[0].lng], {
                            icon: L.divIcon({
                                className: 'custom-marker-start',
                                html: '<div style="background-color: #FFC107; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                                iconSize: [20, 20],
                                iconAnchor: [10, 10]
                            })
                        }).addTo(map);
                        startMarker.bindPopup(`<strong>MaMaMa (D√©part/Arriv√©e)</strong><br>${waypoints[0].address}`);
                        markers.push(startMarker);
                        latlngs.push([waypoints[0].lat, waypoints[0].lng]);
                    }
                    
                    for (let i = 1; i < waypoints.length; i++) {
                        const waypoint = waypoints[i];
                        if (waypoint.lat && waypoint.lng) {
                            const marker = L.marker([waypoint.lat, waypoint.lng], {
                                icon: L.divIcon({
                                    className: 'custom-marker',
                                    html: `<div style="background-color: #FF6B6B; width: 16px; height: 16px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div><div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: bold; white-space: nowrap; box-shadow: 0 1px 3px rgba(0,0,0,0.3);">${i}</div>`,
                                    iconSize: [30, 30],
                                    iconAnchor: [15, 15]
                                })
                            }).addTo(map);
                            
                            const popupText = waypoint.nom 
                                ? `<strong>${i}. ${waypoint.nom}</strong><br>${waypoint.address}`
                                : `<strong>${i}. ${waypoint.address}</strong>`;
                            marker.bindPopup(popupText);
                            markers.push(marker);
                            latlngs.push([waypoint.lat, waypoint.lng]);
                        }
                    }
                    
                    if (latlngs.length > 1) {
                        const polyline = L.polyline(latlngs, {
                            color: '#FF6B6B',
                            weight: 4,
                            opacity: 0.7
                        }).addTo(map);
                        
                        if (latlngs.length > 1 && waypoints[0].lat && waypoints[0].lng && 
                            waypoints[waypoints.length - 1].lat && waypoints[waypoints.length - 1].lng) {
                            const returnLine = L.polyline([
                                [waypoints[waypoints.length - 1].lat, waypoints[waypoints.length - 1].lng],
                                [waypoints[0].lat, waypoints[0].lng]
                            ], {
                                color: '#9E9E9E',
                                weight: 3,
                                opacity: 0.5,
                                dashArray: '10, 5'
                            }).addTo(map);
                        }
                    }
                    
                    if (markers.length > 0) {
                        const group = new L.featureGroup(markers);
                        try {
                            const bounds = group.getBounds();
                            setTimeout(() => {
                                if (!currentMap) {
                                    isMapInitializing = false;
                                    return;
                                }
                                
                                const container = currentMap.getContainer();
                                if (!container || !container.parentNode) {
                                    isMapInitializing = false;
                                    return;
                                }
                                
                                try {
                                    if (bounds && bounds.isValid && bounds.isValid()) {
                                        currentMap.fitBounds(bounds.pad(0.1));
                                    } else {
                                        if (markers.length > 0 && markers[0].getLatLng) {
                                            currentMap.setView(markers[0].getLatLng(), 13);
                                        }
                                    }
                                } catch (e) {
                                    console.warn('Erreur lors de l\'ajustement de la vue:', e);
                                }
                                isMapInitializing = false;
                            }, 150);
                        } catch (e) {
                            console.warn('Erreur lors de la r√©cup√©ration des bounds:', e);
                            isMapInitializing = false;
                        }
                    } else {
                        isMapInitializing = false;
                    }
                });
            }, 50);
            } catch (error) {
                console.error('Erreur dans displayMap:', error);
                const mapContainer = document.getElementById('mapContainer');
                if (mapContainer) {
                    mapContainer.innerHTML = `<p style="padding: 20px; text-align: center; color: red;">Erreur d'affichage de la carte: ${error.message}</p>`;
                }
            } finally {
                setTimeout(() => {
                    isMapInitializing = false;
                }, 100);
            }
        }

        function buildGoogleMapsUrl(waypoints) {
            if (waypoints.length === 0) return { url: '', limited: false };
            
            const origin = encodeURIComponent(waypoints[0].address);
            const destination = encodeURIComponent(waypoints[0].address);
            const maxWaypoints = 9;
            const waypointsList = [];
            const limited = waypoints.length > 10;
            
            for (let i = 1; i < waypoints.length && waypointsList.length < maxWaypoints; i++) {
                waypointsList.push(encodeURIComponent(waypoints[i].address));
            }
            const waypointsParam = waypointsList.join('|');
            
            let url = `https://www.google.com/maps/dir/?api=1&origin=${origin}&destination=${destination}&travelmode=driving`;
            if (waypointsParam) {
                url += `&waypoints=${waypointsParam}`;
            }
            
            return { url, limited };
        }

        function selectAllVisible() {
            document.querySelectorAll('.pmi-checkbox').forEach(cb => {
                const idx = parseInt(cb.dataset.index);
                cb.checked = true;
                selectedPmiIndices.add(idx);
            });
            updateSelectedCount();
        }

        function deselectAllVisible() {
            document.querySelectorAll('.pmi-checkbox').forEach(cb => {
                const idx = parseInt(cb.dataset.index);
                cb.checked = false;
                selectedPmiIndices.delete(idx);
            });
            updateSelectedCount();
        }

        async function geocodeAddress(address) {
            const statusDiv = document.getElementById('customAddressStatus');
            statusDiv.innerHTML = '<span style="color: #666;">‚è≥ G√©ocodage en cours...</span>';
            
            try {
                const encodedAddress = encodeURIComponent(address);
                
                // Essayer d'abord Photon (API de g√©ocodage qui supporte CORS nativement)
                const photonUrl = `https://photon.komoot.io/api/?q=${encodedAddress}&limit=1&lang=fr`;
                
                let data = null;
                let lastError = null;
                
                // Essayer Photon d'abord (support CORS natif)
                try {
                    const response = await fetch(photonUrl, {
                        method: 'GET',
                        mode: 'cors',
                        cache: 'no-cache',
                        headers: {
                            'Accept': 'application/json'
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Erreur HTTP ${response.status}`);
                    }
                    
                    const photonData = await response.json();
                    
                    if (photonData && photonData.features && photonData.features.length > 0) {
                        const feature = photonData.features[0];
                        const coordinates = feature.geometry.coordinates;
                        const properties = feature.properties;
                        
                        return {
                            address: address,
                            lat: coordinates[1],
                            lng: coordinates[0],
                            nom: properties.name || properties.street || 'Adresse personnalis√©e'
                        };
                    }
                } catch (photonError) {
                    console.warn('Erreur avec Photon, tentative avec proxy:', photonError);
                    lastError = photonError;
                }
                
                // Si Photon n'a pas fonctionn√©, essayer avec des proxies CORS pour Nominatim
                if (!data) {
                    const nominatimUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodedAddress}&limit=1&addressdetails=1`;
                    
                    // Liste de proxies CORS √† essayer en cascade
                    const proxyServices = [
                        `https://api.allorigins.win/raw?url=${encodeURIComponent(nominatimUrl)}`,
                        `https://corsproxy.io/?${encodeURIComponent(nominatimUrl)}`
                    ];
                    
                    // Essayer chaque proxy jusqu'√† ce qu'un fonctionne
                    for (const proxyUrl of proxyServices) {
                        try {
                            const response = await fetch(proxyUrl, {
                                method: 'GET',
                                mode: 'cors',
                                cache: 'no-cache',
                                headers: {
                                    'Accept': 'application/json'
                                }
                            });
                            
                            if (!response.ok) {
                                throw new Error(`Erreur HTTP ${response.status}`);
                            }
                            
                            const responseText = await response.text();
                            
                            // Essayer de parser le JSON
                            try {
                                data = JSON.parse(responseText);
                            } catch (parseError) {
                                // Si c'est un proxy qui retourne un wrapper JSON
                                const wrapper = JSON.parse(responseText);
                                if (wrapper.contents) {
                                    data = JSON.parse(wrapper.contents);
                                } else if (wrapper.data) {
                                    data = JSON.parse(wrapper.data);
                                } else {
                                    data = wrapper;
                                }
                            }
                            
                            // Si on a des donn√©es valides, sortir de la boucle
                            if (data && Array.isArray(data) && data.length > 0) {
                                break;
                            }
                        } catch (proxyError) {
                            console.warn(`Erreur avec proxy ${proxyUrl}:`, proxyError);
                            lastError = proxyError;
                            continue; // Essayer le proxy suivant
                        }
                    }
                }
                
                // Si on a des donn√©es de Nominatim via proxy
                if (data && Array.isArray(data) && data.length > 0) {
                    const result = data[0];
                    const lat = parseFloat(result.lat);
                    const lng = parseFloat(result.lon);
                    
                    if (isNaN(lat) || isNaN(lng)) {
                        throw new Error('Coordonn√©es invalides pour cette adresse');
                    }
                    
                    return {
                        address: address,
                        lat: lat,
                        lng: lng,
                        nom: result.display_name ? result.display_name.split(',')[0].trim() : 'Adresse personnalis√©e'
                    };
                }
                
                // Si aucun service n'a fonctionn√©
                if (lastError) {
                    throw new Error('Impossible de se connecter au service de g√©ocodage. V√©rifiez votre connexion internet et r√©essayez.');
                }
                throw new Error('Adresse non trouv√©e. Veuillez √™tre plus pr√©cis (ex: "10 rue de la Paix, 75002 Paris")');
                
            } catch (error) {
                console.error('Erreur de g√©ocodage:', error);
                if (error.message.includes('Failed to fetch') || 
                    error.message.includes('NetworkError') || 
                    error.message.includes('fetch') ||
                    error.message.includes('CORS')) {
                    throw new Error('Impossible de se connecter au service de g√©ocodage. V√©rifiez votre connexion internet et r√©essayez.');
                }
                throw error;
            }
        }

        function updateCustomAddressesList() {
            const listContainer = document.getElementById('customAddressesList');
            const itemsContainer = document.getElementById('customAddressesItems');
            
            if (customAddresses.length === 0) {
                listContainer.style.display = 'none';
                return;
            }
            
            listContainer.style.display = 'block';
            itemsContainer.innerHTML = '';
            
            customAddresses.forEach((addr, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 8px; background-color: white; border-radius: 4px; border: 1px solid #ddd;';
                
                const addressText = document.createElement('span');
                addressText.style.cssText = 'flex: 1; font-size: 0.9em; color: #555;';
                addressText.textContent = `${addr.nom || 'Adresse personnalis√©e'} - ${addr.address}`;
                
                const removeButton = document.createElement('button');
                removeButton.textContent = '‚úï';
                removeButton.style.cssText = 'background-color: #d32f2f; color: white; border: none; border-radius: 3px; width: 24px; height: 24px; cursor: pointer; font-size: 14px; padding: 0; margin-left: 10px;';
                removeButton.title = 'Supprimer cette adresse';
                removeButton.addEventListener('click', () => {
                    customAddresses.splice(index, 1);
                    updateCustomAddressesList();
                    // Effacer le message de statut
                    const statusDiv = document.getElementById('customAddressStatus');
                    if (statusDiv) {
                        statusDiv.innerHTML = '';
                    }
                    calculateRoutes();
                });
                
                itemDiv.appendChild(addressText);
                itemDiv.appendChild(removeButton);
                itemsContainer.appendChild(itemDiv);
            });
        }

        async function handleCustomAddress() {
            const addressInput = document.getElementById('customAddress');
            const address = addressInput.value.trim();
            const statusDiv = document.getElementById('customAddressStatus');
            
            if (!address) {
                statusDiv.innerHTML = '<span style="color: #d32f2f;">‚ö†Ô∏è Veuillez entrer une adresse</span>';
                return;
            }
            
            // V√©rifier si l'adresse n'est pas d√©j√† dans la liste
            const isAlreadyInList = allPmis.some(pmi => 
                pmi.address.toLowerCase() === address.toLowerCase()
            ) || customAddresses.some(addr => 
                addr.address.toLowerCase() === address.toLowerCase()
            );
            
            if (isAlreadyInList) {
                statusDiv.innerHTML = '<span style="color: #d32f2f;">‚ö†Ô∏è Cette adresse est d√©j√† dans la liste</span>';
                return;
            }
            
            const calculateButton = document.getElementById('calculateCustomAddress');
            calculateButton.disabled = true;
            calculateButton.textContent = 'Calcul en cours...';
            
            try {
                const geocodedAddress = await geocodeAddress(address);
                
                // Ajouter l'adresse √† la liste des adresses personnalis√©es
                customAddresses.push(geocodedAddress);
                
                statusDiv.innerHTML = `<span style="color: #2e7d32;">‚úÖ Adresse ajout√©e : ${geocodedAddress.nom}</span>`;
                addressInput.value = '';
                
                // Mettre √† jour la liste des adresses personnalis√©es
                updateCustomAddressesList();
                
                // Recalculer les routes
                await calculateRoutes();
                
            } catch (error) {
                statusDiv.innerHTML = `<span style="color: #d32f2f;">‚ùå Erreur : ${error.message}</span>`;
            } finally {
                calculateButton.disabled = false;
                calculateButton.textContent = 'Calculer';
            }
        }

        function attachEventListeners() {
            const searchPmi = document.getElementById('searchPmi');
            const selectAll = document.getElementById('selectAll');
            const deselectAll = document.getElementById('deselectAll');
            const calculateCustomAddress = document.getElementById('calculateCustomAddress');
            const customAddressInput = document.getElementById('customAddress');
            
            if (searchPmi) {
                searchPmi.addEventListener('input', function(e) {
                    filterPmis(e.target.value);
                });
            }
            
            if (selectAll) {
                selectAll.addEventListener('click', selectAllVisible);
            }
            
            if (deselectAll) {
                deselectAll.addEventListener('click', deselectAllVisible);
            }
            
            if (calculateCustomAddress) {
                calculateCustomAddress.addEventListener('click', handleCustomAddress);
            }
            
            if (customAddressInput) {
                customAddressInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        handleCustomAddress();
                    }
                });
            }
            
            if (typeof PMI_ADDRESSES !== 'undefined' && typeof PMI_DUREES !== 'undefined') {
                initializeFromJS();
            } else {
                window.addEventListener('load', function() {
                    setTimeout(() => {
                        if (typeof PMI_ADDRESSES !== 'undefined' && typeof PMI_DUREES !== 'undefined') {
                            initializeFromJS();
                        } else {
                            console.error('Donn√©es non disponibles apr√®s chargement');
                            document.getElementById('pmiList').innerHTML = 
                                '<p style="color: red;">‚ùå Erreur : Les fichiers de donn√©es JavaScript ne sont pas charg√©s. V√©rifiez que pmi_addresses.js et pmi_durees.js sont pr√©sents.</p>';
                        }
                    }, 100);
                });
            }
        }
        
        attachEventListeners();
    </script>
</body>
</html>

